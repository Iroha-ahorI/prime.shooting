<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Prime Shooter JS版</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      background: black;
      display: block;
    }
    #restartBtn {
      display: none;
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 30px;
      font-size: 22px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 20;
    }

    /* 待機弾列 */
    #bulletQueueDisplay {
      position: fixed;
      top: 20px;
      right: 20px;
      text-align: right;
      color: cyan;
      font-size: 28px;
      z-index: 15;
    }

    /* ランキング表示 */
    #rankingDisplay {
      position: fixed;
      top: 80px;
      left: 20px;
      color: white;
      font-size: 20px;
      z-index: 15;
      line-height: 1.4em;
    }

    /* 操作ボタン */
    #controls {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 30px;
      z-index: 10;
    }
    #verticalBtns {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    #horizontalBtns {
      display: flex;
      flex-direction: row;
      gap: 15px;
    }
    #controls button {
      font-size: 40px;
      padding: 25px;
      background: rgba(255,255,255,0.2);
      color: white;
      border: 3px solid white;
      border-radius: 12px;
      cursor: pointer;
      touch-action: manipulation;
    }
    #controls button:active {
      background: rgba(0,255,0,0.4);
    }
  </style>
</head>

<body>
<canvas id="gameCanvas"></canvas>
<button id="restartBtn">Restart</button>

<div id="bulletQueueDisplay"></div>
<div id="rankingDisplay"></div>

<div id="controls">
  <div id="verticalBtns">
    <button id="upBtn">↑</button>
    <button id="downBtn">↓</button>
  </div>
  <div id="horizontalBtns">
    <button id="leftBtn">←</button>
    <button id="rightBtn">→</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");

function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const WIDTH = ()=>canvas.width;
const HEIGHT = ()=>canvas.height;

let playerX, playerY, bullets, enemies, bulletQueue, enemyTimer, score, lives;
let gameOver;
let effects = [];

function initGame(){
  playerX = WIDTH()/2;
  playerY = HEIGHT() - 50;
  bullets = [];
  enemies = [];
  bulletQueue = Array.from({length:7},()=>bulletNumbers[Math.floor(Math.random()*bulletNumbers.length)]);
  enemyTimer = 0;
  score = 0;
  lives = 2;   // ← ライフ2
  gameOver = false;
  effects = [];
  restartBtn.style.display = "none";
  drawBulletQueue();
}

const bulletNumbers = [2,3,3,4,5,6,7];

class Bullet {
  constructor(x,y,value){ this.x=x; this.y=y; this.value=value; this.speed=-10; }
  update(){ this.y += this.speed; }
  draw(){ ctx.fillStyle="yellow"; ctx.fillText(this.value,this.x,this.y); }
}

class Enemy {
  constructor(x,y,value){ this.x=x; this.y=y; this.value=value; this.speed=1; }
  update(){ this.y += this.speed; }
  draw(){ ctx.fillStyle="red"; ctx.fillText(this.value,this.x,this.y); }
  hit(bulletValue){
    if(this.value % bulletValue === 0){
      this.value = Math.floor(this.value / bulletValue);
      if(this.value === 1) return true;
    }
    return false;
  }
}

function generateComposite(){
  let factors = [];
  let count = Math.floor(Math.random()*2)+2;
  while(factors.length < count){
    let f = bulletNumbers[Math.floor(Math.random()*bulletNumbers.length)];
    if(!factors.includes(f)) factors.push(f);
  }
  return factors.reduce((a,b)=>a*b,1);
}

let keys = {};
document.addEventListener("keydown", e=>{
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)){
    e.preventDefault();
  }
  keys[e.key] = true;
  if(e.key === "ArrowUp"){ shootBullet(); }
  if(e.key === "ArrowDown"){ skipBullet(); }
});
document.addEventListener("keyup", e=>{ keys[e.key] = false; });

document.getElementById("leftBtn").addEventListener("touchstart", ()=> keys["ArrowLeft"]=true);
document.getElementById("leftBtn").addEventListener("touchend", ()=> keys["ArrowLeft"]=false);

document.getElementById("rightBtn").addEventListener("touchstart", ()=> keys["ArrowRight"]=true);
document.getElementById("rightBtn").addEventListener("touchend", ()=> keys["ArrowRight"]=false);

document.getElementById("upBtn").addEventListener("click", ()=> shootBullet());
document.getElementById("downBtn").addEventListener("click", ()=> skipBullet());

function shootBullet(){
  bullets.push(new Bullet(playerX, playerY, bulletQueue[bulletQueue.length-1]));
  bulletQueue.pop();
  bulletQueue.unshift(bulletNumbers[Math.floor(Math.random()*bulletNumbers.length)]);
  drawBulletQueue();
}
function skipBullet(){
  bulletQueue.pop();
  bulletQueue.unshift(bulletNumbers[Math.floor(Math.random()*bulletNumbers.length)]);
  drawBulletQueue();
}

/* 発射弾を除外して待機弾列を表示 */
function drawBulletQueue(){
  const queueDiv = document.getElementById("bulletQueueDisplay");
  queueDiv.innerHTML = bulletQueue.slice(0, bulletQueue.length-1).reverse().join(" ");
}

/* スコア保存（上位5つ） */
function saveScore(score){
  let scores = JSON.parse(localStorage.getItem("scores") || "[]");
  scores.push(score);
  scores.sort((a,b)=>b-a);
  scores = scores.slice(0, 5);
  localStorage.setItem("scores", JSON.stringify(scores));
}

/* ランキング描画 */
function drawRanking(){
  let scores = JSON.parse(localStorage.getItem("scores") || "[]");
  let html = "<b>Top Scores</b><br>";
  scores.forEach((s,i)=> html += `${i+1}. ${s}<br>`);
  document.getElementById("rankingDisplay").innerHTML = html;
}

function update(){
  if(gameOver) return;

  if(keys["ArrowLeft"]) playerX -= 8;
  if(keys["ArrowRight"]) playerX += 8;

  enemyTimer++;
  if(enemyTimer > 450){
    enemies.push(new Enemy(Math.random()*(WIDTH()-200)+50,0,generateComposite()));
    enemyTimer = 0;
  }

  bullets.forEach(b=>b.update());
  bullets = bullets.filter(b=>b.y>0);

  enemies.forEach(enemy=>{
    enemy.update();
    if(enemy.y > playerY){
      lives--;
      enemies = enemies.filter(e=>e!==enemy);
      if(lives<=0){
        gameOver = true;
        saveScore(score);
        restartBtn.style.display="block";
      }
    }
    bullets.forEach(bullet=>{
      if(Math.abs(enemy.x-bullet.x)<40 && Math.abs(enemy.y-bullet.y)<40){
        if(enemy.value % bullet.value === 0){
          if(enemy.hit(bullet.value)){
            let gain = Math.floor((HEIGHT()-enemy.y)/10);
            score += gain;
            enemies = enemies.filter(e=>e!==enemy);
            effects.push({text: "+"+gain, x: enemy.x+30, y: enemy.y, color:"lime", end: Date.now()+500});
          }
        } else {
          score -= 20;
          effects.push({text: "-20", x: enemy.x+30, y: enemy.y, color:"red", end: Date.now()+500});
        }
        bullets = bullets.filter(b=>b!==bullet);
      }
    });
  });
}

function draw(){
  ctx.clearRect(0,0,WIDTH(),HEIGHT());
  ctx.font="24px Arial";

  if(gameOver){
    ctx.fillStyle="red";
    ctx.fillText("GAME OVER", WIDTH()/2-60, HEIGHT()/2);
    ctx.fillStyle="white";
    ctx.fillText("Final Score: "+score, WIDTH()/2-80, HEIGHT()/2+40);
    drawRanking();
    return;
  }

  ctx.fillStyle="green";
  ctx.fillRect(playerX-20, playerY, 40, 20);

  ctx.fillStyle="yellow";
  ctx.fillText(bulletQueue[bulletQueue.length-1], playerX-10, playerY-20);

  bullets.forEach(b=>b.draw());
  enemies.forEach(e=>e.draw());

  effects = effects.filter(eff=> Date.now() < eff.end);
  effects.forEach(eff=>{
    ctx.fillStyle = eff.color;
    ctx.fillText(eff.text, eff.x, eff.y);
  });

  ctx.fillStyle="white";
  ctx.fillText("Score: "+score, 20, 30);
  ctx.fillText("Lives: "+lives, 20, 60);

  drawRanking();
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

restartBtn.addEventListener("click", ()=> initGame());

initGame();
loop();
</script>
</body>
</html>
